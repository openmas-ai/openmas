OpenMAS - Comprehensive Design Document (v0.2.0)
Date: April 23, 2025
Status: Proposed Design
Authors: Wilson Urdaneta <wilson.urdaneta@gmail.com>

Abstract: This document outlines the architecture and design for OpenMAS, a Pythonic ecosystem aimed at simplifying the development, structuring, integration, and deployment of Multi-Agent Systems (MAS). It covers both the core OpenMAS SDK (the foundational library) and the proposed application architecture and tooling designed to enhance the developer experience, drawing inspiration from frameworks like dbt.

Table of Contents:
Introduction & Motivation
Core Principles (Philosophy)
State of the Art & Justification
OpenMAS Ecosystem Overview
OpenMAS SDK Architecture (The Framework - v0.1.0 Foundation)
OpenMAS Application Architecture (The User Experience)
Core Concepts in Practice (Handling Variability)
CLI Tooling (openmas CLI)

Future Considerations & Roadmap
1. Introduction & Motivation
1.1. The Problem: Developing, deploying, and maintaining Multi-Agent Systems (MAS) is complex. Key challenges include:
Integration Complexity: Connecting diverse components (LLMs, specialized engines, external APIs, databases) requires brittle, bespoke code.
Configuration Management: Handling distributed configuration securely and consistently is difficult and error-prone.
Repetitive Boilerplate: Significant code duplication occurs when setting up agent structure, communication, configuration loading, and basic service logic.
Deployment & Operations: Containerization, networking, interaction testing, and monitoring add significant overhead.
Extensibility & Reusability: Adapting systems or adding capabilities often requires substantial refactoring without a modular design.
Application Structuring: Lack of conventions makes organizing, understanding, and scaling MAS application codebases difficult.
Developer Focus: Too much time is spent on plumbing rather than core agent intelligence and logic.

1.2. Project Context: Initial motivation stems from challenges in projects like dylangames-* ChessPal and your chesspal.ai, involving orchestrators, specialized servers (MCP), and deployment complexity. The need to generalize beyond specific domains highlights the requirement for a reusable, structured approach.

1.3. Goal of OpenMAS Ecosystem: To provide a cohesive Pythonic environment that simplifies the end-to-end lifecycle of MAS development. This includes:
A thin, transparent, and extensible SDK (framework) for building individual agent components with reduced boilerplate, focusing on configuration, communication abstraction, and lifecycle management.
An opinionated application structure and conventions (inspired by dbt) to organize MAS projects, promoting modularity and understandability.
CLI tooling to scaffold projects, validate configurations, and facilitate development workflows.
Mechanisms for local and potentially external extensibility without modifying the core SDK.
Ultimately, allowing developers to focus on agent logic and MAS design, rather than foundational plumbing and project organization challenges.

2. Core Principles (Philosophy)
Simplicity & Composability: Favor simple, understandable components. Provide building blocks, avoid opaque magic.
Transparency: Ensure component interactions (especially communication) are reasonably clear to aid debugging.
Modularity & Pluggability: Design for extension (especially communication backends). Foster an ecosystem.
Pragmatism: Focus initially on solving the most pressing pain points (config, communication abstraction, boilerplate reduction, application structure).
Protocol Support (MCP First, Pluggable): Excellent MCP support is primary, but the architecture must support other protocols (HTTP, gRPC, MQ) via pluggable communicators.
Agent Reasoning Agnosticism: The SDK provides the agent's "body" (structure, communication), not its "brain" (reasoning). Supports various internal logic implementations.
Separation of Concerns:
SDK: Manages core agent abstractions (BaseAgent, Communicator), lifecycle, config loading interface.
Application Structure: Organizes developer code (agents/, shared/, extensions/), project config (openmas_project.yml).
Deployment Tools: Handle containerization, networking, runtime config injection (e.g., Docker Compose, Kubernetes, potentially aided by a openmas-deploy tool).

3. State of the Art & Justification
Existing Frameworks:
MCP-Focused (mcp-agent, fast-agent, ADK): Strong on MCP client/workflow patterns, less on MCP server creation or broader protocol/structure needs.
BDI Frameworks (spade-bdi, MASPY): Focus on specific internal reasoning models.
Justification for OpenMAS: Fills a gap by providing a thin, flexible foundation that simplifies building both clients and servers (especially MCP), offers pluggable communication for diverse protocols, remains agnostic to reasoning models, and crucially, introduces a standardized application structure and tooling for better project organization and developer experience, inspired by dbt's success.

4. OpenMAS Ecosystem Overview
The OpenMAS ecosystem consists of two primary parts working together:
OpenMAS SDK (The Framework):
The core Python library (pip install openmas).
Provides fundamental building blocks: BaseAgent, BaseCommunicator implementations, configuration loading utilities, standard exceptions.
Imported and used by developers within their agent code.
Focus: Reducing boilerplate for individual agent components, providing abstractions.
OpenMAS Application Architecture & Tooling (The User Experience):
A set of conventions and tools for structuring a complete MAS project.
Defines a standard directory layout (agents/, shared/, extensions/, etc.).
Includes a central project configuration file (openmas_project.yml).
Provides a CLI tool (openmas) for initializing projects, validation, etc.
Focus: Organizing the overall application, promoting modularity, enabling local extensions, simplifying configuration management, and improving developer workflow.

5. OpenMAS SDK Architecture (The Framework - v0.1.0 Foundation)

5.1. Core Components:
BaseAgent (openmas.agent):
Fundamental class inherited by all OpenMAS components.
Handles initialization boilerplate: loads config via openmas.config, instantiates configured Communicator.
Provides self.name, self.config, self.communicator.
Defines standard async lifecycle methods: setup(), run(), shutdown(). run() contains the component's main logic loop.
Configuration (openmas.config):
Provides load_config(): Standardized function to load agent settings.
Primary source: Environment variables (e.g., AGENT_NAME, COMMUNICATOR_TYPE, SERVICE_URLS, AGENT_PORT, custom params). Easily injected in containerized environments.
Uses Pydantic for validation and type-safe access (self.config).
Can be extended to support layered config (see Section 6.3).
Communicator (openmas.communication):
BaseCommunicator (ABC): Abstract interface defining methods like send_request(), send_notification(), register_handler(), start(), stop(). Key pluggability point.
Initial Implementations: HttpCommunicator (using httpx). Future: McpStdioCommunicator, McpSseCommunicator, GrpcCommunicator, MessageQueueCommunicator.
Instantiated by BaseAgent based on configuration (config.communicator_type).
Exceptions (openmas.exceptions): Custom exceptions (OpenMasError, ConfigurationError, CommunicationError) for consistent error handling.

5.2. Key Abstractions & Benefits:
Unified Base: Common starting point (BaseAgent) reduces boilerplate.
Simplified Setup & Config: Standardized initialization and configuration access.
Decoupled Communication: Communicator abstracts protocol details, allowing agent logic to be cleaner and protocols swappable/added. Agents use logical service names resolved via config.
Testability: Clear interfaces facilitate mocking (e.g., MockCommunicator).

5.3. Relationship to BDI & Workflows:
The SDK is agnostic. It provides the foundation (structure, communication, lifecycle) upon which various reasoning models (like BDI using external libraries) and workflow patterns (like Orchestrator-Worker) can be implemented within BaseAgent subclasses. Optional SDK helpers (openmas.patterns, openmas.integrations) can facilitate these but are not core requirements.

6. OpenMAS Application Architecture (The User Experience)
This defines how developers structure their MAS projects using the OpenMAS SDK, inspired by dbt.

6.1. Standard Directory Structure: Generated by openmas init:
your_mas_project_name/
├── agents/                 # Code for individual agents
│   ├── <agent_name_1>/
│   │   ├── agent.py        # BaseAgent subclass implementation
│   │   ├── requirements.txt # Optional: Agent-specific deps
│   │   └── openmas.deploy.yaml # Deployment metadata
│   └── <agent_name_2>/ ...
├── shared/                 # Shared Python code within this project (utils, models)
├── extensions/             # Project-local OpenMAS extensions (custom communicators, patterns, base agents)
├── config/                 # Optional: Environment-specific config files (e.g., default.yml, production.yml)
├── tests/                  # Application-level integration tests
├── openmas_project.yml   # Central project configuration
├── requirements.txt        # Top-level project dependencies (incl. openmas SDK)
└── README.md


6.2. Central Configuration (openmas_project.yml):
Defines the MAS application structure and metadata.
Contents:
name: Project name.
version: Project version.
agents: Mapping of logical agent names to their directory paths (e.g., orchestrator: agents/orchestrator).
shared_paths: List of directories containing shared code.
extension_paths: List of directories containing project-local extensions. The SDK runtime will be configured to look for modules/classes here.
default_config: Optional default parameters (lowest precedence).
(Future) dependencies: List of external OpenMAS packages.

6.3. Configuration Layering Strategy: Settings are resolved in the following order (higher precedence overrides lower):
OpenMAS SDK Internal Defaults.
default_config section in openmas_project.yml.
Environment-specific YAML files in config/ (e.g., config/production.yml, selected via OPENMAS_ENV env var). Note: SDK load_config needs enhancement for this.
Environment Variables: Read directly by openmas.config.load_config. This is the primary way to inject runtime secrets, service URLs, ports, and agent-specific parameters in deployment.

6.4. Local Extensibility (extensions/):
Allows developers to define custom BaseCommunicator subclasses, specialized BaseAgent types, reusable patterns, etc., specific to their project without modifying the installed openmas SDK.
The SDK's dynamic loading mechanisms (e.g., for communicators via config.communicator_type, or potentially for base agent types) will be configured via openmas_project.yml (extension_paths) to search these directories using Python's import system (sys.path manipulation or importlib).

7. Core Concepts in Practice (Handling Variability)
The combination of the SDK and Application Architecture handles diversity:
Workflow Types (Orchestrator, Chain, etc.):
Implemented primarily as code within specific agent (agent.py) run methods.
Optional SDK helpers (openmas.patterns) can be used.
Configured via agent parameters (e.g., target worker names in SERVICE_URLS).
Project-specific reusable patterns can live in extensions/.
Protocols (HTTP, MCP, gRPC, MQ):
Outgoing: Selected via agent config (COMMUNICATOR_TYPE=...) which tells BaseAgent which Communicator class (from SDK or extensions/) to instantiate.
Incoming: Implemented by the agent starting a server (e.g., FastAPI, gRPC server, MCP server via communicator) in its run() method. Listening address/port configured via env vars. SDK provides lifecycle and potentially MCP decorators/integration.
Reasoning Types (Simple, BDI, etc.):
Implemented entirely within the BaseAgent subclass (agent.py). SDK remains agnostic.
Optional SDK integration hooks/bases (BdiAgent) can ease integration (Prompt 4.1).
Reasoning parameters configured via agent env vars.
Project-specific reasoning helpers can live in extensions/ or shared/.

8. CLI Tooling (openmas CLI)
A command-line interface to streamline the developer workflow:
openmas init <project_name>: Scaffolds the standard application directory structure and a basic openmas_project.yml. Supports templates (e.g., --template=mcp-server).
openmas validate: Parses openmas_project.yml, checks syntax, verifies agent paths exist.
openmas list agents: Lists agents defined in openmas_project.yml.
openmas run <agent_name>: Convenience command to run a specific agent defined in the project (loads config context).
(Future) openmas deps: Installs external OpenMAS package dependencies listed in openmas_project.yml.
(Separate Tool) openmas-deploy: See Future Considerations (9.2).

9. Other

9.1. SDK Enhancements:
Full MCP Support: Implement McpStdioCommunicator, McpSseCommunicator (client/server). Add SDK helpers/decorators (@mcp_tool, etc.) integrating cleanly with BaseAgent (or McpAgent). Integrate MCP Sampling. Refactor/remove McpClientAdapter.

Formalize Communicator Plugin System: Implement robust discovery (entry points + extension_paths) and configuration.

Add More Communicators: gRPC, Message Queues (RabbitMQ/Redis).

Orchestration Pattern Helpers: Optional modules (openmas.patterns) for Orchestrator-Worker, Chaining, Routing.

BDI/Reasoning Integration: Optional hooks or base classes (BdiAgent) for easier integration with external libraries.

Testing Utilities: MockCommunicator, Agent Test Harness (openmas.testing).

Storage/Content System Pluggability: Explore BaseStorage abstraction.

Configuration Enhancement: Implement reading from config/*.yml based on OPENMAS_ENV.

9.2. Application & Tooling Enhancements:
Implement openmas CLI: init, validate, list, run.

Deployment Configuration Generator (openmas-deploy Tool): Standalone tool reads openmas.deploy.yaml metadata from agents (defined in openmas_project.yml) and generates docker-compose.yml / Kubernetes manifests, automating networking/config injection.

Basic Dockerfile Helper: Command within openmas-deploy (or main CLI) to generate standard Dockerfiles.

External Package Management: Implement openmas deps and dependency resolution based on openmas_project.yml.

9.3. Documentation: Continuous improvement of user guides, tutorials, API references, and contribution guidelines. Establish clear docstring policy (e.g., Google Style).
